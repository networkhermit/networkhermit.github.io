<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>hi, I’m vac</title>
	<link href="https://blog.vac.fun/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://blog.vac.fun"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-09-10T00:00:00+00:00</updated>
	<id>https://blog.vac.fun/atom.xml</id>
	<entry xml:lang="en">
		<title>Honeycomb Blog: Authors&#x27; Cut—No More Pipeline Blues: Accelerate CI&#x2F;CD with Observability</title>
		<published>2022-09-10T00:00:00+00:00</published>
		<updated>2022-09-10T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220910-honeycomb/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220910-honeycomb/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;Adding observability to your CI&#x2F;CD pipelines will help you address the issues that are costing you
time and money.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.honeycomb.io&#x2F;blog&#x2F;pipeline-blues-cicd-observability&#x2F;&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Naked Security: How to deal with dates and times without any timezone tantrums…</title>
		<published>2022-09-10T00:00:00+00:00</published>
		<updated>2022-09-10T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220910-nakedsecurity/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220910-nakedsecurity/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;There’s one thing you can do to help, both as a logfile creator and a logfile consumer.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Always reduce timestamps to UTC&lt;&#x2F;strong&gt; (universal co-ordinated time), thus factoring timezones out of
your logfiles, and &lt;strong&gt;always record timestamps in a simple, unambiguous, alphabetically sortable
format&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Simply put: consult, &lt;a href=&quot;https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc3339.txt&quot;&gt;RFC 3339&lt;&#x2F;a&gt;, and stick to &lt;em&gt;Zulu
time&lt;&#x2F;em&gt; timestamps everwhere.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;nakedsecurity.sophos.com&#x2F;2022&#x2F;09&#x2F;09&#x2F;hoe-to-deal-with-dates-and-times-without-any-timezone-tantrums&#x2F;&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Rosieland: Stop Measuring Community Engagement</title>
		<published>2022-09-10T00:00:00+00:00</published>
		<updated>2022-09-10T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220910-rosieland/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220910-rosieland/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;good intentions with bad outcomes&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Engagement is Value-Neutral&lt;&#x2F;strong&gt; &#x2F; &lt;strong&gt;Quantity over Quality&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Engagement is just the mechanism for delivering something of value, it’s not the value itself.
Knowing how much engagement you have doesn’t tell you how much value you’re getting. Engagement
that makes a difference is often what can&#x27;t be seen, and consequently (easily) measured. It’s not
even a good proxy measurement or leading indicator. You could deliver less value with more
engagement, or more value with less engagement. At best it’s a vanity metric. At worst it’s
ticking time bomb.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;We should measure what we value, not value what we measure. Unfortunately for us, human psychology
makes the latter inevitable. So our only hope is in the former, measuring what we value.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;rosie.land&#x2F;posts&#x2F;stop-measuring-community-engagement&#x2F;&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Go: 认识内存一致性模型</title>
		<published>2022-09-07T00:00:00+00:00</published>
		<updated>2022-09-07T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/posts/20220907-memory-model/" type="text/html"/>
		<id>https://blog.vac.fun/posts/20220907-memory-model/</id>
		<content type="html">&lt;h2 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;Go&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1.19&quot;&gt;1.19&lt;&#x2F;a&gt; 发布时更新了内存一致性模型，刚好可以结合 &lt;a href=&quot;https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;&quot;&gt;Russ Cox&lt;&#x2F;a&gt;
之前写的科普向文章一起来理解一下，尽管文章里没有讨论到 &lt;code&gt;GPU&lt;&#x2F;code&gt; 和 &lt;code&gt;Linux Kernel&lt;&#x2F;code&gt; 的内存一致性模型，但
总体上还是有很高的可读性，不记笔记感觉对不起这么好的材料。&lt;&#x2F;p&gt;
&lt;p&gt;P.S. “内存模型”这个名词视语境不同可以有完全不同的解释，我个人建议尽量不要滥用。&lt;&#x2F;p&gt;
&lt;p&gt;memory model:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;address space layout&lt;&#x2F;li&gt;
&lt;li&gt;memory addressing scheme&lt;&#x2F;li&gt;
&lt;li&gt;memory allocation scheme&lt;&#x2F;li&gt;
&lt;li&gt;memory object model&lt;&#x2F;li&gt;
&lt;li&gt;memory ordering&lt;&#x2F;li&gt;
&lt;li&gt;memory segmentation&lt;&#x2F;li&gt;
&lt;li&gt;type layout&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;can-kao-zi-liao&quot;&gt;参考资料&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;research.swtch.com&#x2F;mm&quot;&gt;Memory Models&lt;&#x2F;a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;research.swtch.com&#x2F;hwmm&quot;&gt;Hardware Memory Models&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;research.swtch.com&#x2F;plmm&quot;&gt;Programming Language Memory Models&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;research.swtch.com&#x2F;gomm&quot;&gt;Updating the Go Memory Model&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;mem&quot;&gt;The Go Memory Model&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;tree&#x2F;master&#x2F;tools&#x2F;memory-model&#x2F;Documentation&quot;&gt;Linux-Kernel Memory Model (LKMM)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Standard library:
&lt;ul&gt;
&lt;li&gt;Go: &lt;a href=&quot;https:&#x2F;&#x2F;pkg.go.dev&#x2F;sync&#x2F;atomic&quot;&gt;atomic&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;pkg.go.dev&#x2F;sync&quot;&gt;sync&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Rust: &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;sync&#x2F;atomic&#x2F;&quot;&gt;atomic&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;sync&#x2F;&quot;&gt;sync&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;C++: &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;atomic&quot;&gt;atomic&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;thread&quot;&gt;sync&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;C: &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;atomic&quot;&gt;atomic&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;thread&quot;&gt;sync&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bi-ji-zheng-li&quot;&gt;笔记整理&lt;&#x2F;h2&gt;
&lt;p&gt;memory consistency model:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;about the visibility and consistency of memory operations in multithreaded contexts&lt;&#x2F;li&gt;
&lt;li&gt;cross-disciplinary contract: hardware &amp;lt;-&amp;gt; compilers &amp;lt;-&amp;gt; programmers&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;valid optimizations do not change the behavior of valid programs&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;processor optimizations: largely revolves around how writes are propagated to other threads&lt;&#x2F;li&gt;
&lt;li&gt;compiler optimizations: largely revolves around reordering of instructions&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;data-race-race-condition&quot;&gt;Data Race ∈ Race Condition&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Every race involves at least one write: two uncoordinated reads do not race with each other.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;scpv-sequential-consistency-per-variable-at-atomicity-hb-happens-before-pb-propagates-before&quot;&gt;SCPV (sequential consistency per variable), AT (Atomicity), HB (Happens-before), PB (Propagates-before)&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The total order over all the synchronizing operations is separate from the happens-before
relationship. It is &lt;em&gt;not&lt;&#x2F;em&gt; true that there is a happens-before edge in one direction or the other
between every lock, unlock, or volatile variable access in a program: you only get a
happens-before edge from a write to a read that observes the write.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;guan-jian-yuan-zi-zhi-ling&quot;&gt;关键原子指令&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;read–modify–write (RMW)&lt;&#x2F;li&gt;
&lt;li&gt;compare-and-swap (CAS)&lt;&#x2F;li&gt;
&lt;li&gt;load-linked&#x2F;store-conditional (LL&#x2F;SC) &#x2F; load-reserved&#x2F;store-conditional (LR&#x2F;SC)&lt;&#x2F;li&gt;
&lt;li&gt;load-acquire&#x2F;store-release (LDAR&#x2F;STLR)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;ying-jian-nei-cun-mo-xing-symmetric-multiprocessing&quot;&gt;硬件内存模型 (Symmetric multiprocessing)&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Sequential Consistency: the ideal model&lt;&#x2F;li&gt;
&lt;li&gt;Total Store Order (TSO): &lt;code&gt;x86&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Weak Consistency: &lt;code&gt;RISC-V&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Relaxed Consistency: &lt;code&gt;ARM&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Data-Race-Free Sequential Consistency (DRF-SC): current consensus&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The gap between what is allowed and what is observed makes for unfortunate future surprises:
hardware implementing a stronger model than technically guaranteed encourages dependence on the
stronger behavior and means that future, weaker hardware will break programs, validly or not.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;bian-cheng-yu-yan-nei-cun-mo-xing-concurrency&quot;&gt;编程语言内存模型 (Concurrency)&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;All modern hardware guarantees coherence, which can also be viewed as sequential consistency for
the operations on a single memory location. It turns out that, because of program reordering
during compilation, modern languages do not even provide coherence.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Coherence is easier for hardware to provide than for compilers because hardware can apply dynamic
optimizations: it can adjust the optimization paths based on the exact addresses involved in a
given sequence of memory reads and writes. In contrast, compilers can only apply static
optimizations: they have to write out, ahead of time, an instruction sequence that will be correct
no matter what addresses and values are involved.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Threads Cannot Be Implemented As a Library&lt;&#x2F;em&gt;: languages cannot be silent about the semantics of
multithreaded execution.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;DRF-SC
&lt;ul&gt;
&lt;li&gt;happens-before relation through synchronization operations&lt;&#x2F;li&gt;
&lt;li&gt;total order with interleaved execution&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;atomics (atomic variables&#x2F;atomic operations)
&lt;ul&gt;
&lt;li&gt;non-synchronizing
&lt;ul&gt;
&lt;li&gt;relaxed: for hiding races, provide no ordering, cannot be used to build new synchronization
primitives&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;synchronizing (message receive&#x2F;message send)
&lt;ul&gt;
&lt;li&gt;sequentially consistent (strong)&lt;&#x2F;li&gt;
&lt;li&gt;acquire&#x2F;release (weak): coherence-only, provide limited ordering, create happens-before
relation but do not provide DRF-SC&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;memory barriers&#x2F;fences&lt;&#x2F;li&gt;
&lt;li&gt;high-level synchronization mechanisms
&lt;ul&gt;
&lt;li&gt;semaphore (binary semaphore&#x2F;counting semaphore)&lt;&#x2F;li&gt;
&lt;li&gt;spinlock&lt;&#x2F;li&gt;
&lt;li&gt;barrier&lt;&#x2F;li&gt;
&lt;li&gt;mutex&lt;&#x2F;li&gt;
&lt;li&gt;readers–writer lock&lt;&#x2F;li&gt;
&lt;li&gt;condition variable (signal&#x2F;notify_one and broadcast&#x2F;notify_all)&lt;&#x2F;li&gt;
&lt;li&gt;monitor&lt;&#x2F;li&gt;
&lt;li&gt;channel (buffered&#x2F;unbuffered)&lt;&#x2F;li&gt;
&lt;li&gt;atomic reference counting&lt;&#x2F;li&gt;
&lt;li&gt;once&lt;&#x2F;li&gt;
&lt;li&gt;pool&lt;&#x2F;li&gt;
&lt;li&gt;future (explicit&#x2F;implicit)&lt;&#x2F;li&gt;
&lt;li&gt;futex&lt;&#x2F;li&gt;
&lt;li&gt;sequence lock&lt;&#x2F;li&gt;
&lt;li&gt;read-copy-update&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;semantics for racy programs
&lt;ul&gt;
&lt;li&gt;defines the behavior and possible results&lt;&#x2F;li&gt;
&lt;li&gt;as undefined behavior: DRF-SC or Catch Fire&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;distinguish invalid compiler optimizations&lt;&#x2F;li&gt;
&lt;li&gt;prohibit paradoxes like out-of-thin-air values (acausality)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;xie-zai-zui-hou&quot;&gt;写在最后&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;When it comes to programs with races, both programmers and compilers should remember the advice:
don&#x27;t be clever. (Clear is better than clever.)&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Felienne Blog: Code Reading Club</title>
		<published>2022-09-01T00:00:00+00:00</published>
		<updated>2022-09-01T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220901-felienne/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220901-felienne/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;Programmers in generally are really poorly equipped to &lt;em&gt;read&lt;&#x2F;em&gt; code, even their own code, but
especially code written by others.&lt;&#x2F;p&gt;
&lt;p&gt;Programmers read code less linearly than natural language; they follow the call stack rather than
reading from top to bottom.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.felienne.com&#x2F;archives&#x2F;6472&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>ASPLOS Paper: Frightening Small Children and Disconcerting Grown-ups: Concurrency in the Linux Kernel</title>
		<published>2022-08-31T00:00:00+00:00</published>
		<updated>2022-08-31T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220831-asplos/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220831-asplos/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;All in all, our LK model specifies the cumulative effect of a language-level model (the subset of
C specific to the LK) and the hardware models targeted by the LK.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3173162.3177156&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1608.07531&quot;&gt;Syntax and semantics of the weak consistency model specification language cat&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1308.6810&quot;&gt;Herding Cats: Modelling, Simulation, Testing, and Data Mining for Weak Memory&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Ivan Velichko: Reverse Proxy, HTTP Keep-Alive Timeout, and sporadic HTTP 502s</title>
		<published>2022-08-27T00:00:00+00:00</published>
		<updated>2022-08-27T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220827-iximiuz/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220827-iximiuz/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;HTTP Keep-Alive between a reverse proxy and an upstream server combined with some misfortunate
downstream- and upstream-side timeout settings can make clients receiving HTTP 502s from the
proxy.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;iximiuz.com&#x2F;en&#x2F;posts&#x2F;reverse-proxy-http-keep-alive-and-502s&#x2F;&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.tessian.com&#x2F;blog&#x2F;how-to-fix-http-502-errors&#x2F;&quot;&gt;A Solution to HTTP 502 Errors with AWS ALB&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HTTP_persistent_connection&quot;&gt;HTTP persistent connection&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Die wunderbare Welt von Isotopp: fork, exec, wait and exit</title>
		<published>2022-08-26T00:00:00+00:00</published>
		<updated>2022-08-26T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220826-koehntopp/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220826-koehntopp/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.koehntopp.info&#x2F;2020&#x2F;12&#x2F;28&#x2F;fork-exec-wait-and-exit.html&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;iximiuz.com&#x2F;en&#x2F;posts&#x2F;how-to-on-processes&#x2F;&quot;&gt;How to on starting processes (mostly in Linux)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fork_(system_call)&quot;&gt;fork (system call)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exec_(system_call)&quot;&gt;exec (system call)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wait_(system_call)&quot;&gt;wait (system call)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exit_(system_call)&quot;&gt;exit (system call)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dup_(system_call)&quot;&gt;dup (system call)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pipeline_(Unix)&quot;&gt;Pipeline (Unix)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spawn_(computing)&quot;&gt;Spawn (computing)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fork%E2%80%93exec&quot;&gt;Fork–exec&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fork_bomb&quot;&gt;Fork bomb&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Process_(computing)&quot;&gt;Process (computing)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parent_process&quot;&gt;Parent process&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Child_process&quot;&gt;Child process&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signal_(IPC)&quot;&gt;Signal (IPC)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Orphan_process&quot;&gt;Orphan process&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zombie_process&quot;&gt;Zombie process&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Process_group&quot;&gt;Process group&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>LWN: Docker and the OCI container ecosystem &amp; The container orchestrator landscape</title>
		<published>2022-08-26T00:00:00+00:00</published>
		<updated>2022-08-26T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220826-lwn/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220826-lwn/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;902049&#x2F;&quot;&gt;Docker and the OCI container ecosystem&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;905164&#x2F;&quot;&gt;The container orchestrator landscape&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;iximiuz.com&#x2F;en&#x2F;posts&#x2F;containers-vs-pods&#x2F;&quot;&gt;Containers vs. Pods - Taking a Deeper Look&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;iximiuz.com&#x2F;en&#x2F;posts&#x2F;kubernetes-ephemeral-containers&#x2F;&quot;&gt;Kubernetes Ephemeral Containers and kubectl debug Command&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Linux_namespaces&quot;&gt;Linux namespaces&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cgroups&quot;&gt;cgroups&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Union_mount&quot;&gt;Union mount&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Seccomp&quot;&gt;seccomp&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;OCI &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;opencontainers&#x2F;runtime-spec&quot;&gt;Runtime&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;opencontainers&#x2F;image-spec&quot;&gt;Image&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;opencontainers&#x2F;distribution-spec&quot;&gt;Distribution&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;cri-api&quot;&gt;CRI&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;containernetworking&#x2F;cni&quot;&gt;CNI&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;container-storage-interface&#x2F;spec&quot;&gt;CSI&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Cat-v Archive: Notes on Programming in C</title>
		<published>2022-08-22T00:00:00+00:00</published>
		<updated>2022-08-22T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220822-cat-v/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220822-cat-v/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;Rule 1. You can&#x27;t tell where a program is going to spend its time. Bottlenecks occur in surprising
places, so don&#x27;t try to second guess and put in a speed hack until you&#x27;ve proven that&#x27;s where the
bottleneck is.&lt;&#x2F;p&gt;
&lt;p&gt;Rule 2. Measure. Don&#x27;t tune for speed until you&#x27;ve measured, and even then don&#x27;t unless one part
of the code overwhelms the rest.&lt;&#x2F;p&gt;
&lt;p&gt;Rule 3. Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have
big constants. Until you know that n is frequently going to be big, don&#x27;t get fancy. (Even if n
does get big, use Rule 2 first.) For example, binary trees are always faster than splay trees for
workaday problems.&lt;&#x2F;p&gt;
&lt;p&gt;Rule 4. Fancy algorithms are buggier than simple ones, and they&#x27;re much harder to implement. Use
simple algorithms as well as simple data structures.&lt;&#x2F;p&gt;
&lt;p&gt;The following data structures are a complete list for almost all practical programs:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;array&lt;&#x2F;li&gt;
&lt;li&gt;linked list&lt;&#x2F;li&gt;
&lt;li&gt;hash table&lt;&#x2F;li&gt;
&lt;li&gt;binary tree&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Of course, you must also be prepared to collect these into compound data structures. For instance,
a symbol table might be implemented as a hash table containing linked lists of arrays of
characters.&lt;&#x2F;p&gt;
&lt;p&gt;Rule 5. Data dominates. If you&#x27;ve chosen the right data structures and organized things well, the
algorithms will almost always be self-evident. Data structures, not algorithms, are central to
programming.&lt;&#x2F;p&gt;
&lt;p&gt;Rule 6. There is no Rule 6.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.cat-v.org&#x2F;bell_labs&#x2F;pikestyle&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>LWN: C library system-call wrappers, or the lack thereof</title>
		<published>2022-08-19T00:00:00+00:00</published>
		<updated>2022-08-19T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220819-lwn/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220819-lwn/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;Calling into the kernel is not like calling a normal function; a special trap into the kernel
must be triggered with the system-call arguments placed as the kernel expects. At a minimum, the
system-call &amp;quot;wrapper&amp;quot; provided by the C library must set up this trap. In many cases, more work
than that is required; the functionality provided by the kernel does not always exactly match
what the application (or the relevant standards) will expect. Features like POSIX threads further
complicate the situation. The end result is that a lot of work can be happening between the
application and the kernel when a system call is made. Doing that work is, in most cases,
delegated to the C library.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Free-software projects tend to value their independence; their developers have little time for
others who would tell them what to do. But few projects truly stand alone. Whenever developers
decide to cooperate more fully with related projects, the result tends to be better software for
the community as a whole. The design and delivery of system calls would appear to be one of those
places where a higher level of communication and cooperation would be a healthy thing. That,
rather than trying to absorb low-level wrappers into the kernel project, seems like the proper
long-term solution to this problem.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;771441&#x2F;&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Tokio Blog: Diagnostics with Tracing</title>
		<published>2022-08-19T00:00:00+00:00</published>
		<updated>2022-08-19T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220819-tokio/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220819-tokio/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;Effectively developing systems and operating them in production requires visibility into their
behavior at runtime.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2019-08-tracing&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2021-12-announcing-tokio-console&quot;&gt;Announcing Tokio Console 0.1&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2022-02-announcing-tokio-metrics&quot;&gt;Announcing Tokio Metrics 0.1&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>linusw: Rust in Perspective</title>
		<published>2022-08-18T00:00:00+00:00</published>
		<updated>2022-08-18T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220818-linusw/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220818-linusw/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;Rust is attempting to raise the abstraction in the programming language and ultimately to join
computer science and software engineering into one single discipline, an ambition that has been
around since these disciplines were created.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;What is unique about Rust is that it fuses “impure” functional programming with imperative
programming, and compiled to target machine code from day one.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;people.kernel.org&#x2F;linusw&#x2F;rust-in-perspective&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Tokio Blog: Making the Tokio scheduler 10x faster</title>
		<published>2022-08-18T00:00:00+00:00</published>
		<updated>2022-08-18T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220818-tokio/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220818-tokio/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;The major theme is &amp;quot;reduce.&amp;quot; After all, there is no code faster than no code!&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;reducing allocation&lt;&#x2F;li&gt;
&lt;li&gt;reducing copying&lt;&#x2F;li&gt;
&lt;li&gt;reducing data movement&lt;&#x2F;li&gt;
&lt;li&gt;reducing cache miss&lt;&#x2F;li&gt;
&lt;li&gt;reducing synchronization&lt;&#x2F;li&gt;
&lt;li&gt;reducing contention&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2019-10-scheduler&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2018-03-timers&quot;&gt;New Timer implementation&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2020-04-preemption&quot;&gt;Reducing tail latencies with automatic cooperative task yielding&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Async code should never spend a long time without reaching an .await.&lt;&#x2F;p&gt;
&lt;p&gt;A good rule of thumb is no more than 10 to 100 microseconds between each .await. That said, this
depends on the kind of application you are writing.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ryhl.io&#x2F;blog&#x2F;async-what-is-blocking&#x2F;&quot;&gt;Async: What is blocking?&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Rust RFC &lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;0230-remove-runtime.html&quot;&gt;0230 - remove runtime&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;2394-async_await.html&quot;&gt;2394 - async&#x2F;await&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;2592-futures.html&quot;&gt;2592 - futures&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Concurrency_(computer_science)&quot;&gt;Concurrency (computer science)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Concurrent_computing&quot;&gt;Concurrent computing&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Scheduling_(computing)&quot;&gt;Scheduling (computing)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_(computing)#M:N_(hybrid_threading)&quot;&gt;M:N (hybrid) threading model&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_pool&quot;&gt;Thread pool&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_stealing&quot;&gt;Work stealing&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fork%E2%80%93join_model&quot;&gt;Fork–join model&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Blocking_(computing)&quot;&gt;Blocking (computing)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asynchronous_I&#x2F;O&quot;&gt;Asynchronous I&#x2F;O&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Green_thread&quot;&gt;Green thread&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Coroutine&quot;&gt;Coroutine&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Async&#x2F;await&quot;&gt;Async&#x2F;await&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Futures_and_promises&quot;&gt;Futures and promises&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Finite-state_machine&quot;&gt;Finite-state machine&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Callback_(computer_programming)&quot;&gt;Callback (computer programming)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lazy_evaluation&quot;&gt;Lazy evaluation&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Continuation-passing_style&quot;&gt;Continuation-passing style&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cooperative_multitasking&quot;&gt;Cooperative multitasking&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Preemption_(computing)&quot;&gt;Preemption (computing)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thrashing_(computer_science)&quot;&gt;Thrashing (computer science)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cache_coherence#Coherence_protocols&quot;&gt;Cache coherence protocol&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Resource_contention&quot;&gt;Resource contention&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thundering_herd_problem&quot;&gt;Thundering herd problem&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Permutation_test&quot;&gt;Permutation test&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>LWN: The seven deadly sins of software deployment</title>
		<published>2022-08-17T00:00:00+00:00</published>
		<updated>2022-08-17T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220817-lwn/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220817-lwn/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;The odds of deployment failure approach 100% as the number of distinct change sets approaches
seven.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;If three or more things have gone wrong, roll back.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Three Strikes Rule&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;562333&#x2F;&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Objective Analysis White Paper: The Future of the Data Center: Memory and Storage Take on an Increasing Role</title>
		<published>2022-08-17T00:00:00+00:00</published>
		<updated>2022-08-17T00:00:00+00:00</updated>
		<link rel="alternate" href="https://blog.vac.fun/prism/20220817-objective-analysis/" type="text/html"/>
		<id>https://blog.vac.fun/prism/20220817-objective-analysis/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;reducing data movement&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;offloading processing&lt;&#x2F;strong&gt; (In-Situ Processing)&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Processor in Memory&#x2F;Computational Storage&lt;&#x2F;li&gt;
&lt;li&gt;Edge and Endpoint Processing&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Near Memory&#x2F;Storage &amp;amp; Far Memory&#x2F;Storage&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;As computers share an increasing number of resources, memory has been given a new role. It is no
longer simply a fast place to temporarily save code and data for a single processor, but is now
blossoming into a role in which it also rapidly shares data between processors.&lt;&#x2F;p&gt;
&lt;p&gt;This changes the memory’s role from fast temporary storage to one in which it serves as a
communications medium. If we add in situ processing to that we find that memory begins to take on
roles once devoted to processing and storage.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;objective-analysis.com&#x2F;wp-content&#x2F;uploads&#x2F;2022&#x2F;08&#x2F;Objective-Analysis-Brief-The-Future-of-the-Data-Center.pdf&quot;&gt;Link [pdf]&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Compute_Express_Link&quot;&gt;Compute Express Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
</feed>
