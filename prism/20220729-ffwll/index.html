<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    
    
    <title>
        stuff by danvet: Locking Engineering Principles
    </title>
    

    
    
        <link rel="icon" type="image/x-icon" href=&#x2F;images&#x2F;favicon.ico />
    

    
    
        <link href=https://blog.vac.fun/fonts.css rel="stylesheet" />
    

    
    

    
    <link rel="alternate" type="application/atom+xml" title="hi, I’m vac" href="https://blog.vac.fun/atom.xml">

    
    
    
        <link rel="stylesheet" type="text/css" href="https://blog.vac.fun/theme/light.css"/>
        <link rel="stylesheet" type="text/css" href="https://blog.vac.fun/theme/dark.css" media="(prefers-color-scheme: dark)"/>
    

    <link rel="stylesheet" type="text/css" media="screen" href=https://blog.vac.fun/main.css />


    
</head>


<body>
    <div class="content">
        <header>
    <div class="main">
        <a href=https:&#x2F;&#x2F;blog.vac.fun>hi, I’m vac</a>
    </div>

    <nav>
        
            <a href=&#x2F;posts style="margin-left: 0.7em">&#x2F;posts</a>
        
            <a href=&#x2F;prism style="margin-left: 0.7em">&#x2F;prism</a>
        
            <a href=&#x2F;about style="margin-left: 0.7em">&#x2F;about</a>
        
    </nav>
</header>

        
        
    
<main>
    <article>
        <div class="title">
            
            
    <div class="page-header">
        stuff by danvet: Locking Engineering Principles<span class="primary-color" style="font-size: 1.6em">.</span>
    </div>


                <div class="meta">
                    
                        Posted on <time>2022-07-29</time>
                    

                    
                </div>
        </div>

        

        
        

        <section class="body">
            <blockquote>
<p><strong>Priorities in Locking Engineering</strong></p>
<ul>
<li>Make it Dumb</li>
</ul>
<p>Designing a correct locking scheme is hard, validating that your code actually implements your
design is harder, and then debugging when - not if! - you screwed up is even worse. Therefore the
absolute most important rule in locking engineering, at least if you want to have any chance at
winning this game, is to make the design as simple and dumb as possible.</p>
<ul>
<li>Make it Correct</li>
</ul>
<p>Validating locking by hand against all the other locking designs and nesting rules the kernel has
overall is nigh impossible, extremely slow, something only few people can do with any chance of
success and hence in almost all cases a complete waste of time. We need tools to automate this,
and in the Linux kernel this is lockdep.</p>
<ol>
<li>
<p>Never invent your own locking primitives, you’ll get them wrong, or at least build something
that’s slow. The kernel’s locks are built and tuned by people who’ve done nothing else their
entire career, you wont beat them except in bug count, and that by a lot.</p>
</li>
<li>
<p>The same holds for synchronization primitives.</p>
</li>
<li>
<p>Finally at the intersection of “make it dumb” and “make it correct”, pick the simplest lock
that works, like a normal mutex instead of an read-write semaphore. This is because in general,
stricter rules catch bugs and design issues quicker, hence picking a very fancy “anything goes”
locking primitives is a bad choice.</p>
</li>
</ol>
<ul>
<li>Make it Fast</li>
</ul>
<p>Speed doesn’t matter if you don’t understand the design anymore in the future, you need simplicity
first.</p>
<p>Speed doesn’t matter if all you’re doing is crashing faster. You need correctness before speed.</p>
<p>Finally speed doesn’t matter where users don’t notice it. If you micro-optimize a path that doesn’
t even show up in real world workloads users care about, all you’ve done is wasted time and
committed to future maintenance pain for no gain at all.</p>
<hr />
<p><strong>Protect Data, not Code</strong></p>
<p>A common pitfall is to design locking by looking at the code, perhaps just sprinkling locking
calls over it until it feels like it’s good enough. The right approach is to design locking for
the data structures, which means specifying for each structure or member field how it is protected
against concurrent changes, and how the necessary amount of consistency is maintained across the
entire data structure with rules that stay invariant, irrespective of how code operates on the
data.</p>
</blockquote>
<p><a href="https://blog.ffwll.ch/2022/07/locking-engineering.html">Link</a></p>

        </section>

        

    </article>
</main>


    </div>
</body>

</html>