<!DOCTYPE html>
<html lang="en">
<html class="dark light">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    

    
    
    
    <title>
         stuff by danvet: Locking Engineering Hierarchy
        
    </title>

        
            <meta property="og:title" content="stuff by danvet: Locking Engineering Hierarchy" />
        
     

     
         
     

     
         
    

    
    
        <link rel="icon" type="image/png" href=&#x2F;images&#x2F;favicon.ico />
    

    
    
        <link href=https://blog.vac.fun/fonts.css rel="stylesheet" />
    

    
    

    
    

    
    
    
    
    

    

    
    <link rel="alternate" type="application/atom+xml" title="hi, I’m vac" href="https://blog.vac.fun/atom.xml">


    
    
        <link rel="stylesheet" type="text/css" href=https://blog.vac.fun/theme/light.css />
        <link rel="stylesheet" type="text/css" href="https://blog.vac.fun/theme/dark.css" media="(prefers-color-scheme: dark)" />
    

    <!-- Set the correct theme in the script -->
    <script src=https://blog.vac.fun/js/themetoggle.js></script>
    
        <script>
            if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                setTheme("dark");
            } else {
                setTheme("light");
            }
        </script>
    

    <link rel="stylesheet" type="text/css" media="screen" href=https://blog.vac.fun/main.css />

    
        
            <link rel="stylesheet" href="https://blog.vac.fun/css/theme.css">
        
    
</head>


<body>
    <div class="content">
        <header>
    <div class="main">
        <a href=https:&#x2F;&#x2F;blog.vac.fun>hi, I’m vac</a>

        <div class="socials">
            
        </div>
    </div>

    <nav>
        
        <a href=https://blog.vac.fun/posts style="margin-left: 0.5em">&#x2F;posts</a>
        
        <a href=https://blog.vac.fun/prism style="margin-left: 0.5em">&#x2F;prism</a>
        
        <a href=https://blog.vac.fun/about style="margin-left: 0.5em">&#x2F;about</a>
        

        
    </nav>
</header>


        
        
    
<main>
    <article>
        <div class="title">
            
            
    <div class="page-header">
        stuff by danvet: Locking Engineering Hierarchy<span class="primary-color" style="font-size: 1.6em">.</span>
    </div>


                <div class="meta">
                    
                        Posted on <time>2022-08-04</time>
                    

                    

                    

                    
                    

                    
                    

                    

                </div>
        </div>

        

        
        

        <section class="body">
            <blockquote>
<p>This part goes through a pile of locking patterns and designs, from most favourable and easiest to
adjust and hence resulting in a long term maintainable code base, to the least favourable since
hardest to ensure it works correctly and stays that way while the code evolves.</p>
<p><strong>Level 0: No Locking</strong></p>
<ul>
<li>Locking Pattern: Immutable State</li>
<li>Locking Pattern: Single Owner</li>
<li>Locking Pattern: Reference Counting</li>
</ul>
<p><strong>Level 1: Big Dumb Lock</strong></p>
<p><strong>Level 2: Fine-grained Locking</strong></p>
<ul>
<li>Locking Pattern: Object Tracking Lists</li>
<li>Locking Pattern: Interrupt Handler State</li>
<li>Locking Pattern: Async Processing</li>
<li>Locking Pattern: Weak References</li>
<li>Locking Antipattern: Confusing Object Lifetime and Data Consistency</li>
</ul>
<p><strong>Level 2.5: Splitting Locks for Performance Reasons</strong></p>
<p>We’ve looked at a pile of functional reasons for complicating the locking design, but sometimes
you need to add more fine-grained locking for performance reasons. This is already getting
dangerous, because it’s very tempting to tune some microbenchmark just because we can, or maybe
delude ourselves that it will be needed in the future. Therefore only complicate your locking if:</p>
<ul>
<li>You have actual real world benchmarks with workloads relevant to users that show measurable
gains outside of statistical noise.</li>
<li>You’ve fully exhausted architectural changes to outright avoid the overhead, like io_uring
pre-registering file descriptors locally to avoid manipulating the file descriptor table.</li>
<li>You’ve fully exhausted algorithm improvements like batching up operations to amortize locking
overhead better.</li>
</ul>
<p>Only then make your future maintenance pain guaranteed worse by applying more tricky locking than
the bare minimum necessary for correctness. Still, go with the simplest approach, often converting
a lock to its read-write variant is good enough.</p>
<p><strong>Level 3: Lockless Tricks</strong></p>
<ul>
<li>Locking Antipattern: Using RCU</li>
<li>Locking Antipattern: Atomics</li>
<li>Locking Antipattern: <code>preempt/local_irq/bh_disable()</code> and Friends …</li>
<li>Locking Antipattern: Memory Barriers</li>
</ul>
<p><strong>Closing Thoughts</strong></p>
<p>Simple, dumb locking is good locking, since with that you have a fighting chance to make it
correct locking.</p>
</blockquote>
<p><a href="https://blog.ffwll.ch/2022/08/locking-hierarchy.html">Link</a></p>
<p><a href="https://lwn.net/Articles/844224/">An introduction to lockless algorithms</a></p>

        </section>
    </article>
</main>



        

    </div>
</body>

</html>
